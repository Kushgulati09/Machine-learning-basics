{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import tensorflow as tf\n",
    "from tensorflow.keras import layers, datasets, models\n",
    "from tensorflow.keras.layers import Conv1D, MaxPooling1D, Flatten, Dense, Bidirectional, Reshape\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "data = np.load('/kaggle/input/dataset/train_data.npy', allow_pickle=True)\n",
    "labels =  np.load('/kaggle/input/dataset/train_labels.npy',allow_pickle=True)\n",
    "\n",
    "\n",
    "X = data[:12000,0] \n",
    "bound = data[:12000,1]\n",
    "\n",
    "new_X = []\n",
    "new_Y = []\n",
    "\n",
    "for i in range(len(X)): \n",
    "    \n",
    "    for j in range(len(bound[i])): \n",
    "        \n",
    "        if j != len(bound[i]) - 1:\n",
    "            inp = (X[i][bound[i][j]:bound[i][j+1]])\n",
    "        else:\n",
    "            inp = (X[i][bound[i][j]:]) \n",
    "\n",
    "        a = (inp.shape)[0]\n",
    "        \n",
    "        if a < 60: \n",
    "\n",
    "            if a%2 == 0: \n",
    "               inp_padded = np.pad(inp,((int((60-a)/2),int((60-a)/2)),(0,0)), mode = 'constant', constant_values = 0)\n",
    "            else: \n",
    "               inp_padded = np.pad(inp,(((60-a)//2,((60-a)//2 + 1)),(0,0)), mode = 'constant', constant_values = 0)\n",
    "        \n",
    "        else:   \n",
    "            \n",
    "            inp_padded = inp[:60,:]    \n",
    "\n",
    "        new_X.append(inp_padded)  \n",
    "        new_Y.append(labels[i][j]) \n",
    "\n",
    "final_input = np.array(new_X)\n",
    "final_output = np.array(new_Y) \n",
    "\n",
    "\n",
    "model = tf.keras.Sequential()\n",
    "model.add(Conv1D(filters=32, kernel_size=3, activation='relu', input_shape=(60,40)))\n",
    "model.add(MaxPooling1D(pool_size=2))\n",
    "model.add(Conv1D(filters=64, kernel_size=3, activation='relu'))\n",
    "model.add(MaxPooling1D(pool_size=2))\n",
    "model.add(Conv1D(filters=128, kernel_size=3, activation='gelu'))\n",
    "model.add(MaxPooling1D(pool_size=2))\n",
    "model.add(Conv1D(filters=256, kernel_size=3, activation='relu'))\n",
    "model.add(MaxPooling1D(pool_size=2))\n",
    "\n",
    "\n",
    "model.add(Flatten())\n",
    "model.add(Dense(256, activation='relu'))\n",
    "model.add(Dense(128, activation='gelu'))\n",
    "model.add(Dense(46, activation='softmax'))\n",
    "\n",
    "model.compile(\n",
    "        optimizer=\"adam\",\n",
    "        loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),\n",
    "        metrics=[\"accuracy\"],\n",
    "    )\n",
    "\n",
    "model.fit(final_input, final_output, batch_size=500, epochs=10)\n",
    "model.save('Kush_Model.h5')\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "from tensorflow.keras.models import Model\n",
    "from tensorflow.keras.models import load_model\n",
    "import numpy as np\n",
    "\n",
    "model = load_model('/kaggle/input/model/Kush_Model.h5')\n",
    "\n",
    "val_input_data =  np.load('/kaggle/input/dataset/dev_data.npy', allow_pickle=True)\n",
    "val_labels =  np.load('/kaggle/input/dataset/dev_labels.npy', allow_pickle=True)\n",
    "\n",
    "X_val = val_input_data[:,0]\n",
    "bound_val = val_input_data[:,1]\n",
    "new_X_val = []\n",
    "new_Y_val = []\n",
    "for i in range(len(X_val)):\n",
    "    \n",
    "    for j in range(len(bound_val[i])):\n",
    "        \n",
    "        if j != len(bound_val[i]) - 1:\n",
    "            inp_val = (X_val[i][bound_val[i][j]:bound_val[i][j+1]])\n",
    "        else:\n",
    "            inp_val = (X_val[i][bound_val[i][j]:])\n",
    "\n",
    "        a = (inp_val.shape)[0]\n",
    "        \n",
    "        if a < 60:  \n",
    "\n",
    "            if a%2 == 0:\n",
    "               inp_padded_val = np.pad(inp_val,((int((60-a)/2),int((60-a)/2)),(0,0)), mode = 'constant', constant_values = 0)\n",
    "            else:\n",
    "               inp_padded_val = np.pad(inp_val,(((60-a)//2,((60-a)//2 + 1)),(0,0)), mode = 'constant', constant_values = 0)\n",
    "        \n",
    "        else:   \n",
    "            \n",
    "            inp_padded_val = inp_val[:60,:]    \n",
    "\n",
    "        new_X_val.append(inp_padded_val)\n",
    "        new_Y_val.append(val_labels[i][j])\n",
    "\n",
    "final_input_val = np.array(new_X_val)\n",
    "final_output_val = np.array(new_Y_val)\n",
    "\n",
    "model.evaluate(final_input_val, final_output_val, verbose=2)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from tensorflow.keras.models import Model\n",
    "from tensorflow.keras.models import load_model\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import tensorflow as tf\n",
    "from tensorflow.keras import layers, datasets, models\n",
    "model = load_model('/kaggle/input/model/Kush_Model.h5')\n",
    "\n",
    "test_input_data =  np.load('/kaggle/input/dataset/test_data.npy', allow_pickle=True)\n",
    "\n",
    "X_test = test_input_data[:,0]\n",
    "bound_test = test_input_data[:,1]\n",
    "new_X_test = []\n",
    "\n",
    "for i in range(len(X_test)):\n",
    "    \n",
    "    for j in range(len(bound_test[i])):\n",
    "        \n",
    "        if j != len(bound_test[i]) - 1:\n",
    "            inp_test = (X_test[i][bound_test[i][j]:bound_test[i][j+1]])\n",
    "        else:\n",
    "            inp_test = (X_test[i][bound_test[i][j]:])\n",
    "\n",
    "        a = (inp_test.shape)[0]\n",
    "        \n",
    "        if a < 60:\n",
    "\n",
    "            if a%2 == 0:\n",
    "               inp_padded_test = np.pad(inp_test ,((int((60-a)/2),int((60-a)/2)),(0,0)), mode = 'constant', constant_values = 0)\n",
    "            else:\n",
    "               inp_padded_test = np.pad(inp_test,(((60-a)//2,((60-a)//2 + 1)),(0,0)), mode = 'constant', constant_values = 0)\n",
    "        \n",
    "        else:   \n",
    "            \n",
    "            inp_padded_test = inp_test[:60,:]\n",
    "        \n",
    "        new_X_test.append(inp_padded_test)\n",
    "        \n",
    "\n",
    "final_input_test = np.array(new_X_test)\n",
    "\n",
    "probability_model = tf.keras.Sequential([model, tf.keras.layers.Softmax()])\n",
    "predictions = probability_model.predict(final_input_test)\n",
    "\n",
    "\n",
    "label_list = []\n",
    "for i in range(len(final_input_test)): \n",
    "  \n",
    "  label = np.argmax(predictions[i], axis = 0, out = None)\n",
    "  print(label)\n",
    "  label_list.append(label)\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    " \n",
    "id = np.arange(0,len(final_input_test))\n",
    "\n",
    "     \n",
    "series = pd.Series(data=label_list, index=id)\n",
    "\n",
    "print(series)\n",
    "series.to_csv('output_file.csv')\n",
    "series.to_csv(r'/kaggle/working/output_file.csv')\n",
    "\n"
   ]
  }
 ],
 "metadata": {
  "language_info": {
   "name": "python"
  },
  "orig_nbformat": 4
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
